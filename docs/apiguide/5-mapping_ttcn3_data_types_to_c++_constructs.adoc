[[mapping-ttcn-3-data-types-to-c-constructs]]
= Mapping TTCN–3 Data Types to C++ Constructs

The TTCN–3 language elements of the test suite are individually mapped into more or less equivalent C++ constructs. The data types are mapped to C++ classes, the test cases become C++ functions, and so on. In order to write a Test Port, it is inevitable to be familiar with the internal representation format of TTCN–3 data types and values. This section gives an overview about the data types and their equivalent C++ constructs.

== Mapping of Names and Identifiers

In order to identify the TTCN–3 language elements in the generated C++ program properly, the names of test suite are translated to C++ identifiers according to the following simple rules.

If the TTCN–3 identifier does not contain any underscore (_) character, its equivalent C++ identifier will be the same. For example, the TTCN–3 variable MyVar will be translated to a C++ variable called MyVar.

If the TTCN–3 identifier contains one or more underscore characters, each underscore character will be duplicated in the C++ identifier. So the TTCN–3 identifier My_Long_Name will be mapped to a C++ identifier called My__Long__Name.

The idea behind this name mapping is that we may freely use the C++ identifiers containing one underscore character in the generated code and in the Test Ports as well. Otherwise name clashes can always happen because the name space of TTCN–3 and C++ is identical. Furthermore, the generated C++ language elements fulfill the condition that the scope of a translated C++ identifier is identical as the scope of the original TTCN–3 identifier.

The identifiers that are keywords of C or C++ but not keywords in TTCN–3 are mapped to themselves, but a single underscore character is appended at the end (for example typedef becomes typedef_). The same rule applies to the all-uppercase identifiers that are used in the Base Library: identifier INTEGER in TTCN–3 becomes INTEGER_ in C++, TRUEfootnote:[The built-in verdict and boolean constants in TTCN–3 shall be written with all lowercase letters, such as true or pass. Although previous compiler versions have accepted TRUE or PASS as well, these words are treated by the compiler as regular identifiers as specified in the standard.] is mapped to TRUE_, etc.

Here is the complete list (in alphabetical order) of the identifiers that are handled in such special way:asm, auto, bitand, bitor, bool, break, case, class, compl, continue, delete, double, enum, explicit, export, friend, inline, int, ischosen, long, main, mutable, namespace, new, operator, private, protected, public, register, short, signed, static, stderr, stdin, stdout, struct, switch, this, throw, try, typedef, typeid, typename, unsigned, using, virtual, void, volatile, ADDRESS, BITSTRING, BOOLEAN, CHAR, CHARSTRING, COMPONENT, DEFAULT, ERROR, FAIL, FALSE, FLOAT, HEXSTRING, INCONC, INTEGER, NONE, OBJID, OCTETSTRING, PASS, PORT, TIMER, TRUE, VERDICTTYPE.

The identifiers that are the names of common preprocessor macros of the C library (such as putchar, errno or NULL) should be avoided in TTCN–3 modules. The name clashes with macros can cause mysterious compilation error messages.

Note that these name mapping rules apply to *all* TTCN–3 identifiers, including module, Test Port, type, field, variable and function names.

WARNING! By default, from version 1.2.pl0 the compiler does NOT duplicate the underscores in output file names and file references (for example when handling imports).

== Namespaces

The compiler generates a C++ namespace for every TTCN–3 and ASN.1 module. All C++ definitions that belong to the module (including Test Port classes and external functions) are placed in that namespace. The name of the namespace is derived from the module identifier according to the rules described in section 5.1.

The definitions of the TTCN–3 Base Library do not use any namespace.

When accessing a C++ entity that belongs to a different module than the referring Test Port or external function is in the reference has to be prefixed with the namespace of the referenced module. For example, to access the C++ class that realizes type MyType defined in MyModule1 from a Test Port that belongs to module MyModule2 the reference shall be written as MyModule1::MyType.

[[predefined-ttcn-3-data-types]]
== Predefined TTCN–3 Data Types

There are some basic data types in TTCN–3 that have no equivalent data types in language C/C++ (for example bitstring, verdicttype). Other types have C++ equivalent, but the TTCN–3 executor must know whether a variable has a valid value or not because sending an unbound value must result in a dynamic test case error. Thus, in the TTCN–3 Base Library all basic data types of TTCN–3 were implemented as C++ classes. This section describes the member functions of these classes.

=== Integer

The TTCN–3 type integer is implemented in class INTEGER.The class INTEGER has the following public member functions:

Table Public member functions of the class INTEGER

[cols=",",options="header",]
|==================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals
|_Arithmetic operators_ |Unary plus.
|_Casting operator_ |Returns the value.
|_Other member functions_ |Puts the value into log.
|==================================================

The comparison, arithmetic and shifting operators are also available as global functions for that case when the left side is int and the right side is INTEGER. Using the value of an unbound variable for anything will cause dynamic test case error.

The casting operator int() is applicable only to INTEGER objects holding a signed value with at most 31 useful bits, since in C/C++ the native int type is 32-bit large including the sign bit. Casting an INTEGER object holding a bigger (for example a 32-bit unsigned) value will result in run-time error.

Please note that if the value stored in an INTEGER object is too big (that is, it cannot be represented as a long long int) the value returned by get_long_long_val() will contain only the lowest sizeof(long long int) bytes of the original value. Another way to obtain a value of a number having more useful bits than 31 is to convert the INTEGER object to its string representation using the int2str() predefined function. Then the string value can be converted to any native integer type using the sscanf() library function or such. The following example demonstrates a common scenario:

unsigned int get_unsigned_int_val(const INTEGER& other_value)

\{

unsigned int ret_val = 0;

sscanf((const char *)int2str(), ``%u'', &ret_val);

return ret_val;

}

In addition, the following global functions are available for modulo division. These functions return the result of mod and rem operations according to TTCN–3 semantics.

INTEGER mod(const INTEGER& left_operand, const INTEGER& right_operand);

INTEGER mod(const INTEGER& left_operand, int right_operand);

INTEGER mod(int left_operand, const INTEGER& right_operand);

INTEGER mod(int left_operand, int right_operand);

INTEGER rem(const INTEGER& left_operand, const INTEGER& right_operand);

INTEGER rem(const INTEGER& left_operand, int right_operand);

INTEGER rem(int left_operand, const INTEGER& right_operand);

INTEGER rem(int left_operand, int right_operand);

Other operators (global functions):

INTEGER operator+(int int_value, const INTEGER& other_value); // Add INTEGER operator-(int int_value, const INTEGER& other_value); // Subtract INTEGER operator*(int int_value, const INTEGER& other_value); // Multiply INTEGER operator/(int int_value, const INTEGER& other_value); // Divide boolean operator==(int int_value, const INTEGER& other_value); // Equal boolean operator!=(int int_value, const INTEGER& other_value); // Not equal boolean operator<(int int_value, const INTEGER& other_value); // Less than boolean operator>(int int_value, const INTEGER& other_value); // More than

=== Float

The TTCN–3 type float is implemented in class FLOAT.The class FLOAT has the following public member functions:

Table Public member functions of the class FLOAT

[width="100%",cols="50%,50%",options="header",]
|=================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|Assignment operators |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals
|_Arithmetic operators_ |Unary plus.
|_Casting operator_ |Returns the value.
|_Other member functions_ |Puts the value into log, either in exponential or decimal dot notation.
|=================================================================================================

The comparison and arithmetic operators are also available as global functions for that case when the left side is double and the right side is FLOAT. Using the value of an unbound variable for anything will cause dynamic test case error.

Other operators (global functions):

FLOAT operator+(double double_value, const FLOAT& other_value); // Add FLOAT operator-(double double_value, const FLOAT& other_value); // Subtract FLOAT operator*(double double_value, const FLOAT& other_value); // Multiply FLOAT operator/(double double_value, const FLOAT& other_value); // Divide boolean operator==(double double_value, const FLOAT& other_value); // Equal boolean operator!=(double double_value, const FLOAT& other_value); // Not equal boolean operator<(double double_value, const FLOAT& other_value); // Less than boolean operator>(double double_value, const FLOAT& other_value); // More than

=== Boolean

The TTCN–3 type boolean is implemented in class BOOLEAN.We have introduced an ancillary C enumerated type called boolean to set and get values. It may have two predefined values: TRUE or FALSE. You may use boolean values in C conditions since FALSE equals to zero and TRUE is not zero.The class BOOLEAN has the following public member functions:

Table Public member functions of the class BOOLEAN

[cols=",",options="header",]
|==================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals
|_Logical operators_ |Negation (NOT).
|_Casting operator_ |Returns the value.
|_Other member functions_ |Puts the value into log.
|==================================================

The comparison and logical operators are also available as global functions for that case when the left side is boolean and the right side is BOOLEAN. Using the value of an unbound variable for anything will cause dynamic test case error.

Other operators (global functions):

BOOLEAN operator&&(boolean bool_value, const BOOLEAN& other_value); // And BOOLEAN operator^(boolean bool_value, const BOOLEAN& other_value); // Not BOOLEAN operator||(boolean bool_value, const BOOLEAN& other_value); // Or boolean operator==(boolean bool_value, const BOOLEAN& other_value); // Equal boolean operator!=(boolean bool_value, const BOOLEAN& other_value);// Not equal

=== Verdicttype

The TTCN–3 type verdicttype is implemented in class VERDICTTYPE.We have introduced an ancillary C enumerated type called verdicttype to set and get values. It may have five predefined values: NONE, PASS, INCONC, FAIL or ERROR. The order of these values is NONE < PASS < INCONC < FAIL < ERROR.The class VERDICTTYPE has the following public member functions:

Table Public member functions of the class VERDICTTYPE

[cols=",",options="header",]
|==================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals
|_Casting operator_ |Returns the value.
|_Other member functions_ |Puts the value into log.
|==================================================

The comparison operators are also available as global functions for that case when the left side is verdicttype and the right side is VERDICTTYPE. Using the value of an unbound VERDICTTYPE variable for anything will cause dynamic test case error.

From version 1.2.pl0 there are the following three static member functions in class TTCN_Runtime defined in the Base Library for getting or modifying the local verdict of the current test components:

void TTCN_Runtime::setverdict(verdicttype);

void TTCN_Runtime::setverdict(const VERDICTTYPE&);

verdicttype TTCN_Runtime::getverdict();

These functions are the C++ equivalents of TTCN–3 setverdict and getverdict operations. Use them only if your Test Port or C++ function encounters a low-level failure, but it can continue its normal operation (that is, error recovery is not necessary).

Other operators (global functions):

boolean operator==(verdicttype par_value, const VERDICTTYPE& other_value); // Equal boolean operator!=(verdicttype par_value, const VERDICTTYPE& other_value); // Not equal

=== Bitstring

The equivalent C++ class of TTCN–3 type bitstring is called BITSTRING. The bits of the bit string are stored in an array of unsigned characters. In order to reduce the wasted memory space the bits are packed together, so each character contains eight bits. The first character contains the first eight bits of the bit string; the second byte contains the bits from the 9th up to the 16th, and so on. The first bit of the bit string is the LSB of the first character; the second bit is the second least significant bit of the first character, and so on. The character array is not terminated with a NUL character and if the length of the bit string is not a multiple of eight, the unused bits of the last character can contain any value. So the length of the bit string must be always given.

The class BITSTRING has the following public member functions:

Table Public member functions of the class BITSTRING

[width="100%",cols="50%,50%",options="header",]
|==============================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value
|Comparison operators |Returns TRUE if equals
|_Concatenation operator_ |Concatenates two bitstrings.
|_Index operator_ |Gives access to the given element. Indexing begins from zero. Index overflow causes dynamic test case error.
|Bitwise operators |C++ equivalent of operator
|_Shifting and rotating operators_ |C++ equivalent of operator
|_Casting operator_ |Returns a pointer to the character array.
|Other member functions |Returns the length measured in bits.
|==============================================================================================================================

Using the value of an unbound BITSTRING variable for anything will cause dynamic test case error.

==== Bitstring element

The C++ class BITSTRING_ELEMENT is the equivalent of the TTCN-3 bitstring’s element type (the result of indexing a bitstring value). The class does not store the actual bit, only a reference to the original BITSTRING object, an index value and a bound flag.

Note: changing the value of the BITSTRING_ELEMENT (through the assignment operator) changes the referenced bit in the original bitstring object.

The class BITSTRING_ELEMENT has the following public member functions:

Table Public member functions of the class BITSTRING_ELEMENT

[width="100%",cols="50%,50%",options="header",]
|========================================================================================================================================================
|Member functions |Notes
|_Constructor_ |Initializes the object with an unbound value or a reference to a bit in an existring BITSTRING object.
|_Assignment operators_ |Sets the referenced bit to the given bitstring of length 1.
|Comparison operators |Comparison with a bitstring or a bitstring element (the value of the referenced bits is compared, not the references and indexes).
|_Concatenation operator_ |Concatenates a bitstring element with a bitstring, or two bitstring elements.
|Bitwise operators |C++ equivalent of operator
|Other member functions |Returns the referenced bit.
|========================================================================================================================================================

Using the value of an unbound BITSTRING_ELEMENT variable for anything will cause dynamic test case error.

=== Hexstring

The equivalent C++ class of TTCN–3 type hexstring is called HEXSTRING. The hexadecimal digits (nibbles) are stored in an array of unsigned characters. In order to reduce the wasted memory space two nibbles are packed into one character. The first character contains the first two nibbles of the hexstring, the second byte contains the third and fourth nibbles, and so on. The hexadecimal digits at odd (first, third, fifth, etc.) positions occupy the lower 4 bits in the characters; the even ones use the upper 4 bits. The character array is never terminated with a NUL character, so the length must be always given with the pointer. If the hexstring has odd length the unused upper 4 bits of the last character may contain any value.

The class HEXSTRING has the following public member functions:

Table Public member functions of the class HEXSTRING

[width="100%",cols="50%,50%",options="header",]
|==============================================================================================================================
|Member functions |Notes
|Constructors |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals and FALSE otherwise.
|_Concatenation operator_ |Concatenates two hexstrings.
|_Index operator_ |Gives access to the given element. Indexing begins from zero. Index overflow causes dynamic test case error.
|_Bitwise operators_ |C++ equivalent of operator
|_Shifting and rotating operators_ |C++ equivalent of operator
|_Casting operator_ |Returns a pointer to the character array. The pointer might be NULL if the length is 0.
|_Other member functions_ |Returns the length measured in nibbles.
|==============================================================================================================================

Using the value of an unbound HEXSTRING variable for anything will cause a dynamic test case error.

==== Hexstring element

The C++ class HEXSTRING_ELEMENT is the equivalent of the TTCN-3 hexstring’s element type (the result of indexing a hexstring value). The class does not store the actual hexadecimal digit (nibble), only a reference to the original HEXSTRING object, an index value and a bound flag.

Note: changing the value of the HEXSTRING_ELEMENT (through the assignment operator) changes the referenced nibble in the original hexstring object.

The class HEXSTRING_ELEMENT has the following public member functions:

Table Public member functions of the class HEXSTRING_ELEMENT

[width="100%",cols="50%,50%",options="header",]
|===========================================================================================================================================================
|Member functions |Notes
|_Constructor_ |Initializes the object with an unbound value or a reference to a nibble in an existring HEXSTRING object.
|_Assignment operators_ |Sets the referenced nibble to the given hexstring of length 1.
|Comparison operators |Comparison with a hexstring or a hexstring element (the value of the referenced nibbles is compared, not the references and indexes).
|_Concatenation operator_ |Concatenates a hexstring element with a hexstring, or two hexstring elements.
|Bitwise operators |C++ equivalent of operator
|Other member functions |Returns the referenced nibble (stored in the lower 4 bits of the returned character).
|===========================================================================================================================================================

Using the value of an unbound HEXSTRING_ELEMENT variable for anything will cause dynamic test case error.

=== Octetstring

The equivalent C++ class of TTCN–3 type octetstring is called OCTETSTRING. The octets are stored in an array of unsigned characters. Each character contains one octet; the first character is the first octet of the string. The character array is not terminated by a NUL character, so the length of the octet string must be always given.

The class OCTETSTRING has the following public member functions:

Table Public member functions of the class OCTETSTRING

[width="100%",cols="50%,50%",options="header",]
|==============================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals
|_Concatenation operator_ |Concatenates two octetstrings.
|_Index operator_ |Gives access to the given element. Indexing begins from zero. Index overflow causes dynamic test case error.
|_Bitwise operators_ |C++ equivalent of operator not4b.
|_Shifting and rotating operators_ |C++ equivalent of operator <<.
|_Casting operator_ |Returns a pointer to the character array. The pointer might be NULL if the length is 0.
|_Other member functions_ |Returns the length measured in octets.
|==============================================================================================================================

Using the value of an unbound OCTETSTRING variable for anything will cause dynamic test case error.

==== Octetstring element

The C++ class OCTETSTRING_ELEMENT is the equivalent of the TTCN-3 octetstring’s element type (the result of indexing an octetstring value). The class does not store the actual octet, only a reference to the original OCTETSTRING object, an index value and a bound flag.

Note: changing the value of the OCTETSTRING_ELEMENT (through the assignment operator) changes the referenced octet in the original octetstring object.

The class OCTETSTRING_ELEMENT has the following public member functions:

Table Public member functions of the class OCTETSTRING_ELEMENT

[width="100%",cols="50%,50%",options="header",]
|================================================================================================================================================================
|Member functions |Notes
|_Constructor_ |Initializes the object with an unbound value or a reference to an octet in an existring OCTETSTRING object.
|_Assignment operators_ |Sets the referenced octet to the given octetstring of length 1.
|Comparison operators |Comparison with an octetstring or an octetstring element (the value of the referenced octets is compared, not the references and indexes).
|_Concatenation operator_ |Concatenates an octetstring element with an octetstring, or two octetstring elements.
|Bitwise operators |C++ equivalent of operator
|Other member functions |Returns the referenced octet.
|================================================================================================================================================================

Using the value of an unbound OCTETSTRING_ELEMENT variable for anything will cause dynamic test case error.

=== Char

The char type, which has been removed from the TTCN–3 standard, is no longer supported by the run-time environment. The compiler substitutes all occurrences of char type with type charstring automatically.

To provide partial backward compatibility for older Test Ports that might have used the type char, CHAR is a typedef alias to class CHARSTRING in C++.

=== Charstring

The equivalent C++ class of TTCN–3 type charstring is called CHARSTRING. The characters are stored in a NUL character terminated array; thus, giving the length in the constructor and other operations is optional.

The class CHARSTRING has the following public member functions:

Table Public member functions of the class CHARSTRING

[width="100%",cols="50%,50%",options="header",]
|==============================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the given value and sets the bound flag.
|_Comparison operators_ |Returns TRUE if equals and FALSE otherwise.
|_Concatenation operator_ |Concatenates two charstrings.
|_Index operator_ |Gives access to the given element. Indexing begins from zero. Index overflow causes dynamic test case error.
|_Rotating operators_ |C++ equivalent of operator < @.(rotate left)
|_Casting operator_ |Returns a pointer to the character array. The string is always terminated by NUL.
|Other member functions |Returns the length measured in characters not including the terminator NUL.
|==============================================================================================================================

The comparison, concatenation and rotating operators are also available as global functions for that case when the left side is const char* and the right side is CHARSTRING.

The log() member function uses single character output for regular characters, but special characters (such as the quotation mark, backslash or newline characters) are printed using the escape sequences of the C language. Non-printable control characters are printed in TTCN–3 quadruple notation, where the first three octets are always zero. The concatenation operator (&) is used between the fragments when necessary. Note that the output does not always conform to TTCN–3 Core Language syntax, but it is always recognized by both our compiler and the configuration file parser.

Using the value of an unbound CHARSTRING variable for anything will cause dynamic test case error.

Other operators (global functions):

boolean operator==(const char* string_value, const CHARSTRING& other_value); // Equal boolean operator==(const char* string_value, const CHARSTRING_ELEMENT& other_value); // Equal boolean operator!=(const char* string_value, const CHARSTRING& other_value); // Not equal boolean operator!=(const char* string_value, const CHARSTRING_ELEMENT& other_value); // Not equal CHARSTRING operator+(const char* string_value, const CHARSTRING& other_value); // Concatenation CHARSTRING operator+(const char* string_value, const CHARSTRING_ELEMENT& other_value); // Concatenation

==== Charstring element

The C++ class CHARSTRING_ELEMENT is the equivalent of the TTCN-3 charstring’s element type (the result of indexing a charstring value). The class does not store the actual character, only a reference to the original CHARSTRING object, an index value and a bound flag.

Note: changing the value of the CHARSTRING_ELEMENT (through the assignment operator) changes the referenced character in the original charstring object.

The class CHARSTRING_ELEMENT has the following public member functions:

Table Public member functions of the class CHARSTRING_ELEMENT

[width="100%",cols="50%,50%",options="header",]
|================================================================================================================================================================================================================================================================================
|Member functions |Notes
|_Constructor_ |Initializes the object with an unbound value or a reference to a character in an existring CHARSTRING object.
|_Assignment operators_ |Sets the referenced character to the given null-terminated string of length 1.
|Comparison operators |Comparison with a null-terminated string, a charstring, a universal charstring, a charstring element or a universal charstring element (when comparing element types, the value of the referenced characters is compared, not the references and indexes).
|_Concatenation operator_ |Concatenates this object with a null-terminated string, a charstring, a charstring element, a universal charstring or a universal charstring element.
|Other member functions |Returns the referenced character.
|================================================================================================================================================================================================================================================================================

Using the value of an unbound CHARSTRING_ELEMENT variable for anything will cause dynamic test case error.

=== Universal char

This obsolete TTCN–3 type is converted automatically to universal charstring in the parser.

=== Universal charstring

Each character of a universal charstring value is represented in the following C structure defined in the Base Library:

struct universal_char \{

unsigned char uc_group, uc_plane, uc_row, uc_cell;

};

The four components of the quadruple (that is, group, plane, row and cell) are stored in fields uc_group, uc_plane, uc_row and uc_cell, respectively. All fields are 8bit unsigned numeric values with the possible value range 0 .. 255.

In case of single-octet characters, which can be also given in TTCN–3 charstring notation (between quotation marks), the fields uc_group, uc_plane, uc_row are set to zero. If tuple notation was used for an ASN.1 string value fields uc_row and uc_cell carry the tuple and the others are set to zero.

Except when performing encoding or decoding, the run-time environment does not check whether the quadruples used in the following API represent valid character positions according to [8]. Moreover, if ASN.1 multi-octet character string values are used, it is not verified whether the elements of such strings are permitted characters of the corresponding string type.

The C++ equivalent of TTCN–3 type universal charstring is implemented in class UNIVERSAL_CHARSTRING. The characters of the string are stored in an array of structure universal_char. The array returned by the casting operator is not terminated with a special character, thus, the length of the string must be always considered when doing operations with the array. The length of the string, which can be obtained by using member function lengthof(), is measured in characters (quadruples) and not bytes.

For the more convenient usage the strings containing only single-octet characters can also be used with class UNIVERSAL_CHARSTRING. Therefore some polymorphic member functions and operators have variants that take const char* as argument. In these member functions the characters of the NUL character terminated string are implicitly converted to quadruples with group, plane and row fields set to zero. NULL pointer as argument means the empty string for these functions.

The class UNIVERSAL_CHARSTRING has the following public member functions:

Table Public member functions of the class UNIVERSAL_CHARSTRING

[width="100%",cols="50%,50%",options="header",]
|==============================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns another string.
|_Comparison operators_ |Returns TRUE if the strings are identical or FALSE otherwise.
|_Concatenation operator_ |Concatenates two strings.
|_Index operator_ |Gives access to the given element. Indexing begins from zero. Index overflow causes dynamic test case error.
|_Rotating operators_ |C++ equivalent of operator < @(rotate left).
|_Casting operator_ |Returns a pointer to the array of characters. There is no terminator character at the end.
|_UTF-8 encoding and decoding_ |Appends the UTF-8 representation of the string to the given buffer
|_Other member functions_ |Returns the length measured in characters.
|==============================================================================================================================

The comparison and concatenation operators are also available as global functions for that case when the left operand is a single-octet string (const char*) or a single character (const universal_char&) and the right side is UNIVERSAL_CHARSTRING value. Using the value of an unbound UNIVERSAL_CHARSTRING variable for anything causes dynamic test case error.

The UNIVERSAL_CHARSTRING variable used with the decode_utf8() method must be newly constructed (unbound) or clean_up() must have been called, otherwise a memory leak will occur.

The logged printout of universal charstring values is compatible with the TTCN–3 notation for such strings. The format to be used depends on the contents of the string. Each character (quadruple) is classified whether it is directly printable or not. The string is fragmented based on this classification. Each fragment consists of either a single non-printable character or a maximal length contiguous sequence of printable characters. The fragments are logged one after another separated by an & character (concatenation operator). The printable fragments use the normal charstring notation; the non-printable characters are logged in the TTCN–3 quadruple notation. An empty universal charstring value is represented by a pair of quotation marks (like in case of empty charstring values).

An example printout in the log can be the following. The string consists of two fragments of printable characters and a non-printable quadruple, which stands for Hungarian letter ``ű'':

``Character'' & char(0, 0, 1, 113) & " is a letter of Hungarian alphabet"

Other operators (global functions):

boolean operator==(const universal_char& left_value, const universal_char& right_value); // Equal boolean operator==(const universal_char& uchar_value, const UNIVERSAL_CHARSTRING& other_value); // Equal boolean operator==(const char* string_value, const UNIVERSAL_CHARSTRING& other_value); // Equal boolean operator==(const universal_char& uchar_value, const UNIVERSAL_CHARSTRING_ELEMENT& other_value); // Equal boolean operator==(const char* string_value, const UNIVERSAL_CHARSTRING_ELEMENT& other_value); // Equal boolean operator!=(const universal_char& left_value, const universal_char& right_value); // Not equal boolean operator!=(const universal_char& uchar_value, const UNIVERSAL_CHARSTRING& other_value); // Not equal boolean operator!=(const char* string_value, const UNIVERSAL_CHARSTRING& other_value); // Not equal boolean operator!=(const universal_char& uchar_value, const UNIVERSAL_CHARSTRING_ELEMENT& other_value); // Not equal boolean operator!=(const char* string_value, const UNIVERSAL_CHARSTRING_ELEMENT& other_value); // Not equal boolean operator<(const universal_char& left_value, const universal_char& right_value& other_value); // Character comparison UNIVERSAL_CHARSTRING operator+(const universal_char& uchar_value, const UNIVERSAL_CHARSTRING& other_value); // Concatenation UNIVERSAL_CHARSTRING operator+(const char* string_value, const UNIVERSAL_CHARSTRING& other_value); // Concatenation UNIVERSAL_CHARSTRING operator+(const universal_char& uchar_value, const UNIVERSAL_CHARSTRING_ELEMENT& other_value); // Concatenation UNIVERSAL_CHARSTRING operator+(const char* string_value, const UNIVERSAL_CHARSTRING_ELEMENT& other_value); // Concatenation

==== Universal charstring element

The C++ class UNIVERSAL_CHARSTRING_ELEMENT is the equivalent of the TTCN-3 universal charstring’s element type (the result of indexing a universal charstring value). The class does not store the actual character, only a reference to the original UNIVERSAL_CHARSTRING object, an index value and a bound flag.

Note: changing the value of the UNIVERSAL_CHARSTRING_ELEMENT (through the assignment operator) changes the referenced character in the original universal charstring object.

The class UNIVERSAL_CHARSTRING_ELEMENT has the following public member functions:

Table Public member functions of the class UNIVERSAL_CHARSTRING_ELEMENT

[width="100%",cols="50%,50%",options="header",]
|=======================================================================================================================================================================================================================================================================================================
|Member functions |Notes
|_Constructor_ |Initializes the object with an unbound value or a reference to a character in an existring UNIVERSAL_CHARSTRING object.
|_Assignment operators_ |Sets the referenced character to the given universal character.
|Comparison operators |Comparison with a universal character, a null-terminated string, a charstring, a universal charstring, a charstring element or a universal charstring element (when comparing element types, the value of the referenced characters is compared, not the references and indexes).
|_Concatenation operator_ |Concatenates this object with a universal character, a null-terminated string, a charstring, a charstring element, a universal charstring or a universal charstring element.
|Other member functions |Returns the referenced character.
|=======================================================================================================================================================================================================================================================================================================

Using the value of an unbound UNIVERSAL_CHARSTRING_ELEMENT variable for anything will cause dynamic test case error.

=== Object Identifier Type

The object identifier type of TTCN–3 (objid) is implemented in class OBJID. In the run-time environment the components of object identifier values are represented in NumberForm, that is, in integer values. The values of components are stored in an array with a given length. The type of the components is specified with a typedef, objid_element. Class OBJID has the following member functions.

Table Public member functions of the class OBJID

[width="100%",cols="50%,50%",options="header",]
|=====================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operator_ |Assigns the given value and sets the bound flag.
|_Comparison operators_ |Returns TRUE if the two values are equal and FALSE otherwise.
|_Indexing operators_ |Returns a reference to the _i th_ component.
|_Casting operator_ |Returns a pointer to the read-only array of components.
|_Other member functions_ |Returns the number of components.
|=====================================================================================

Note: The constructor with variable number of arguments is useful in situations when the number of components is constant and known at compile time.

Using the value of an unbound OBJID variable for anything will cause dynamic test case error.

=== Component References

TTCN–3 variables the types of which are defined as component types are used for storing component references to PTCs. The internal representation of component references are test tool dependent, our test executor handles them as small integer numbers.

All TTCN–3 component types are mapped to the same C++ class, which is called COMPONENT, using typedef aliases. We also use an ancillary C type called component, which is defined as an alias for int:

typedef int component;

There are some predefined constants of component references in TTCN–3. These are defined as C preprocessor macros in the following way:

Table Predefined component references

[cols=",,",options="header",]
|===================================================
|TTCN–3 constant |Preprocessor symbol |Numeric value
|null |NULL |COMPREF 0
|mtc |MTC |COMPREF 1
|system |SYSTEM |COMPREF 2
|===================================================

The class COMPONENT has the following public member functions:

Table Public member functions of the class COMPONENT

[width="100%",cols="50%,50%",options="header",]
|===========================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment_ _operators_ |Assigns the given value
|_Comparison operators_ |Returns TRUE if equals
|Casting operator |Returns the value.
|Other member functions |Puts the value into log in decimal form or in symbolic format for special constants. Like 3 or mtc.
|===========================================================================================================================

Component references are managed by MC. All new test components are given a unique reference that was never used in the test campaign before (not even in a previous test case). The new numbers are increasing monotonously. The reference of the firstly created component is 3; the next one will be 4, and so on.

Using the value of an unbound component reference for anything will cause dynamic test case error.

Other operators (global functions):

boolean operator==(component component_value, const COMPONENT& other_value); // Equal boolean operator!=(component component_value, const COMPONENT& other_value); // Not equal

=== Empty Types

Empty record and set types are not real built-in types in TTCN–3, but the C++ realization of these types also differs from regular records or sets. The empty types are almost identical to each other, only their names are different. That is why we treat them as predefined types.

Each empty type is defined in a C++ class, which is generated by the compiler. Using separate classes enables us to differentiate among them in C++ type polymorphism. For example, several empty types can be defined as incoming or outgoing types on the same TTCN–3 port type.

Let us consider the following TTCN–3 type definition as an example:

type record Dummy \{};

The generated class will rely on an enumerated C type null_type, which is defined as follows:

enum null type \{NULL VALUE };

The only possible value stands for the TTCN–3 empty record or array value (that is for ``\{}''), which is the only possible value of TTCN–3 type Dummy. Note that this type and value is also used in the definition of record of and set of type construct.

The generated C++ class Dummy will have the following member functions:

Table Public member functions of the class Dummy

[width="100%",cols="50%,50%",options="header",]
|================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns the only possible value and sets the bound flag.
|_Comparison operators_ |Returns TRUE if both arguments are bound.
|_Other member functions_ |Puts the value, that is, \{}, into log.
|================================================================================

Setting the only possible value is important, because using the value of an unbound variable for anything will cause dynamic test case error.

Other operators (global functions):

boolean operator==(null_type null_value, const Dummy& other_value);// Equal boolean operator!=(null_type null_value, const Dummy& other_value);// Not equal

== Compound Data Types

The user-defined compound data types are implemented in C++ classes. These classes are generated by the compiler according to type definitions. In contrast with the basic types, these classes can be found in the generated code.

=== Record and Set Type Constructs

The TTCN–3 type constructs record and set are mapped in an identical way to C++. There will be a C++ class for each record type in the generated code. This class builds up the record from its fields.footnote:[This section deals with the record and set types that have at least one field. See Section 4.3.14 for the C++ mapping of empty record and set types.] The fields can be either basic or compound types.

Let us consider the following example type definition. The types t1 and t2 can be arbitrary.

type record t3 \{

t1 f1,

t2 f2

}

The generated class t3 will have the following public member functions:

Table Public member functions of the class t3

[width="100%",cols="50%,50%",options="header",]
|=====================================================================================
|Member functions |Notes
|_Constructors_ |Initializes all fields to unbound value.
|_Destructor_ |
|_Assignment operator_ |Assigns the given value and setsthe bound flag for each field.
|_Comparison operators_ |Returns TRUE if all fields are equal and FALSE otherwise.
|_Field access functions_ |Gives access to the first/second field.
|_Other member functions_ |Returns the size (number of fields).
|=====================================================================================

The record value is unbound if one or more fields of it are unbound. Using the value of an unbound variable for anything (even for comparison) will cause dynamic test case error.

==== Optional Fields in Records and Sets

TTCN–3 permits optional fields in record and set type definitions. An optional field does not have to be always present, it can be omitted. But the omission must be explicitly denoted. Let us change our last example to this.

type record t3 \{

t1 f1,

t2 f2 optional

}

The optional fields are implemented using a C++ template class called OPTIONAL that creates an optional value from any type. In the definition of the generated class t3 the type t2 will be replaced by OPTIONAL<t2> everywhere and anything else will not be changed.

The instantiated template class OPTIONAL<t2> will have the following member functions:

Table Public member functions of the class OPTIONAL<t2>

[width="100%",cols="50%,50%",options="header",]
|================================================================================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operators_ |Assigns omit value, if the right value is OMIT VALUE.
|_Comparison operators_ |Returns TRUE if the value is omit and the right side is OMIT VALUE or FALSE otherwise.
|_Casting operators_ |Gives read-write access to the value. If the value was not previously present, sets the bound flag true and the value will be initialized to unbound.
|_Function call operators_ |Gives read-write access to the value. If the value was not previously present, sets the bound flag true and the value will be initialized to unbound.
|_Other member functions_ |Returns TRUE if the value is present, FALSE if the value is omit or causes dynamic test case error if the value is unbound.
|================================================================================================================================================================================

In some member functions of the template class OPTIONAL the enumerated C type template_sel is used. It has many possible values, but in the optional class only OMIT_VALUE can be used, which stands for the TTCN–3 omit. Usage of other predefined values of template_sel will cause dynamic test case error.

Using the value of an unbound optional field for anything will also cause dynamic test case error.

=== Union Type Construct

The TTCN–3 type construct union is implemented in a C++ class for each union type in the generated code. This class may contain any, but exactly one of its fields. The fields can be either basic or compound types or even identical types.

Let us consider the following example type definition. The types t1 and t2 can be arbitrary.

type union t3 \{

t1 f1,

t2 f2

}

An ancillary enumerated type is created in the generated class t3, which represents the selection:

enum union_selection_type \{ UNBOUND_VALUE = 0, ALT_f1 = 1, ALT_f2 = 2 };

The type t3::union_selection_type is used to distinguish the fields of the union. The predefined constant values are generated as t3::ALT_<field name>.

The generated class t3 will have the following public member functions:

Table Public member functions of the class t3

[width="100%",cols="50%,50%",options="header",]
|=========================================================================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operator_ |Assigns the given value.
|_Comparison operators_ |Returns TRUE if the selections and field values are equal and FALSE otherwise.
|_Field access functions_ |Selects and gives access to the first field. If other field was previously selected, its value will be destroyed.
|_Other member functions_ |Returns the current selection. It will return t3::UNBOUND VALUE if the value is unbound, t3::ALT_f1 if the first field was selected, and so on.
|=========================================================================================================================================================================

Using the value of an unbound union variable for anything will cause dynamic test case error.

==== The anytype

The TTCN-3 anytype is implemented as a C++ class named anytype. The class is generated only if an actual anytype access is present in the module. It has the same interface as any other C++ class generated for a union, with a few differences:

If a field is a built-in type or the address type, the name used in union_selection_type is the name of the runtime class implementing the type (usually the name of the type in all uppercase).

If a field is a user-defined type, the mapping rules in section 5.1 above apply.

The names of field accessor functions are prefixed with AT_. This is necessary, because otherwise the accessor function looks like a constructor to C++.

For example, for the following module

module anyuser \{ type record myrec \{} control \{ var anytype v_at; }}with \{ extension ``anytype integer, myrec, charstring''}

The generated class name will be ``anytype''. The union_selection_type enumerated type will be:

enum union_selection_type \{ UNBOUND_VALUE = 0, ALT_INTEGER = 1, ALT_myrec = 2, ALT_CHARSTRING = 3 };

The field accessor methods will be:

INTEGER& AT_INTEGER();myrec& AT_myrec();CHARSTRING& AT_CHARSTRING();

=== Record of Type Construct

The TTCN–3 type construct record of makes a variable length sequence from one given type. This construct is implemented as a C++ class.

Let us consider the following example type definition. The type t1 can be arbitrary.

type record of t1 t2;

This definition will be translated to a C++ class that will be called t2.

There is an enum type called null_type defined in the Base Library that has only one possible value. NULL_VALUE stands for the empty ``record of'' value, that is, for \{}.

Class t2 will have the following public member functions:

Table Public member functions of the class t2

[width="100%",cols="50%,50%",options="header",]
|==================================================================================================================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment operator_ |Assigns the empty value.
|_Comparison operators_ |Returns TRUE if the two values are equal and FALSE otherwise.
|_Index operators_ |Gives access to the given element. Indexing begins from zero. If this element of the variable was never used before, new (unbound) elements will be allocated up to (and including) this index.
|_Rotating operators_ |C++ equivalent of operator <@. (rotate left)
|_Concatenation operator_ |Concatenates two arrays.
|_Other member functions_ |Returns the number of elements, that is, the largest used index plus one and zero for the empty value.
|==================================================================================================================================================================================================================

A record of value is unbound if no value has been assigned to it or it has at least one unbound element. Using the value of an unbound record of variable for anything will cause dynamic test case error.

Starting with the largest index improves performance when filling a record of value.

Other operators (global functions):

boolean operator==(null_type null_value, const t2& other_value); // Equal boolean operator!=(null_type null_value, const t2& other_value); // Not equal

==== Pre-generated record of and set of constructs

The C++ classes for the record of and set of constructs of most predefined TTCN-3 types are pre-generated and part of the TITAN runtime. Only a type alias (C++ typedef) is generated for instances of these types declared in TTCN-3 and ASN.1 modules. There is a class with regular memory allocation and one with optimized memory allocation pre-generated for each type. These classes are located in the PreGenRecordOf namespace.

Table Pre-generated classes for record of/set of predefined types

[width="100%",cols="50%,50%",options="header",]
|====================================================================================================================================
|C++ class name |Equivalent type in TTCN-3
|**PREGEN__RECORD__OF__BOOLEAN** |*record of boolean*
|**PREGEN__RECORD__OF__INTEGER** |*record of integer*
|**PREGEN__RECORD__OF__FLOAT** |*record of float*
|**PREGEN__RECORD__OF__BITSTRING** |*record of bitstring*
|**PREGEN__RECORD__OF__HEXSTRING** |*record of hexstring*
|**PREGEN__RECORD__OF__OCTETSTRING** |*record of octetstring*
|**PREGEN__RECORD__OF__CHARSTRING** |*record of charstring*
|**PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING** |*record of universal charstring*
|**PREGEN__RECORD__OF__BOOLEAN__OPTIMIZED** |*record of boolean with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__INTEGER__OPTIMIZED** |*record of integer with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__FLOAT__OPTIMIZED** |*record of float with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__BITSTRING__OPTIMIZED** |*record of bitstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__HEXSTRING__OPTIMIZED** |*record of hexstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__OCTETSTRING__OPTIMIZED** |*record of octetstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__CHARSTRING__OPTIMIZED** |*record of charstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING__OPTIMIZED** |*record of universal charstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__BOOLEAN** |*set of boolean*
|**PREGEN__SET__OF__INTEGER** |*set of integer*
|**PREGEN__SET__OF__FLOAT** |*set of float*
|**PREGEN__SET__OF__BITSTRING** |*set of bitstring*
|**PREGEN__SET__OF__HEXSTRING** |*set of hexstring*
|**PREGEN__SET__OF__OCTETSTRING** |*set of octetstring*
|**PREGEN__SET__OF__CHARSTRING** |*set of charstring*
|**PREGEN__SET__OF__UNIVERSAL__CHARSTRING** |*set of universal charstring*
|**PREGEN__SET__OF__BOOLEAN__OPTIMIZED** |*set of boolean with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__INTEGER__OPTIMIZED** |*set of integer with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__FLOAT__OPTIMIZED** |*set of float with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__BITSTRING__OPTIMIZED** |*set of bitstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__HEXSTRING__OPTIMIZED** |*set of hexstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__OCTETSTRING__OPTIMIZED** |*set of octetstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__CHARSTRING__OPTIMIZED** |*set of charstring with \{ extension ``optimize:memalloc'' }*
|**PREGEN__SET__OF__UNIVERSAL__CHARSTRING__OPTIMIZED** |*set of universal charstring with \{ extension ``optimize:memalloc'' }*
|====================================================================================================================================

=== Set of Type Construct

The set of construct of TTCN–3 is implemented similarly to record of. The external interface of this class is exactly the same as in case of record of. For more details please see the previous section.

In the internal implementation only the equality operator differs. Unlike in record of, it considers the unordered property of the set of type construct, that is, it returns TRUE if it is able to find exactly one pair for each element.

The index is a unique identifier for a set of element because the C++ class does not reorder the elements when a new element is added or an element is modified. The copy constructor also keeps the original order of elements.

=== Enumerated Types

The TTCN–3 enumerated type construct is implemented as a C++ class with an embedded enum type.

type enumerated Day \{ Monday (1), Tuesday, Wednesday (3) };

The example above will result in the following, very similar C enum type definition which is embedded in the C++ class Day:

enum enum_type \{ Monday = 1, Tuesday = 0, Wednesday = 3, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 4 };

The automatic assignment of numeric values is done according to the standard. Note that there are two extra enumerated values in C, which stand for the unknown and unbound values. They are used in the conversion functions described below. The compiler assigns the smallest two non-negative integer numbers that are not used by the user-defined enumerated values to the unknown and unbound values.

When using the C enum type and its values from user code the names must be prefixed with the C++ class name. The enum type in the above example can be referenced with Day::enum_type, its values can be accessed as Day::Monday, Day::Tuesday, and so on.

The class Day will have the following public member functions:

Table Public member functions of the class Day

[width="100%",cols="50%,50%",options="header",]
|=========================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|Destructor |
|_Assignment operator_ |Converts the given numeric value to Day::enum_type and assigns it. Only valid values are accepted.
|_Comparison operators_ |Returns TRUE if the two values are equal and FALSE otherwise.
|_Casting operator_ |Returns the enum_value.
|_Static conversion functions_ |See below.
|_Non-static conversion functions_ |See below
|_Other member functions_ |Puts the value into log. Like this: Monday
|=========================================================================================================================

The static member function Day::enum_to_str converts the given parameter of type Day::enum_type to a NULL terminated C character string. It returns the string ”<unknown>”, if the input is not a valid value of the TTCN–3 enumerated type. The returned string is read-only, it must not be modified.

The function Day::str_to_enum does the conversion in the reverse direction. It converts the symbolic enumerated identifier represented by a C character string back to the Day::enum_type equivalent. It returns the value Day::UNKNOWN_VALUE if the input string is not the equivalent of any of the possible values in the enumerated type. The behavior of this function is undefined if the input parameter does not point to an addressable memory area.

In the above two functions the strings are treated case sensitive and they shall not contain any whitespace or other characters that are not part of the enumerated value. In case of ASN.1 ENUMERATED types the strings used by enum_to_str, str_to_enum and log represent the TTCN–3 view of the enumerated value, that is, the hyphenation characters are mapped to a single underscore character. For example, if an ASN.1 enumerated type has a value with name my-enum-value and numeric value 2, the function enum_to_str will return the string ``my_enum_value'' if the input parameter equals to 2. Of course, its C++ equivalent will be my_enum_value with numeric value 2.

Static member function Day::is_valid_enum returns the Boolean value TRUE if there is a defined enumerated value having numeric value equal to the int parameter and FALSE otherwise.

The static member function Day::enum_to_int converts the given parameter of type Day or Day::enum_type to its numeric value. The member function as_int does the same thing for the enumerated instance.

The member function int_to_enum initializes the enumerated instance with the enumerated value having numeric value equal to the given int parameter. A dynamic test case error is displayed if there is no such enumerated value. The member function from_int does the same thing.

If a value of type int is passed to the constructor or assignment operator the value is accepted only if it is a numerical representation of a valid enumerated value, that is, the function is_valid_enum returns TRUE. A dynamic test case error occurs otherwise.

To avoid run-time errors at the decoding of invalid messages the Test Port writer should use the constructor or assignment operator in this way:

Day myDayVar;

int myIntVar = buffer[position];

if (Day::is_valid_enum(myIntVar)) myDayVar = myIntVar;

else myDayVar = Day::UNKNOWN_VALUE;

Using the value of an unbound enumerated variable for anything will cause dynamic test case error.

=== The address Type

The special TTCN–3 data type address is represented in C++ as if it was a regular data type. The name of the equivalent C++ class is ADDRESS. If it is an alias to another (either built-in or user-defined) type then a C++ typedef is used.

== Predefined Functions

Annex C of [1] and Annex B of [3] define a couple of predefined functions. Most of them perform conversion between the built-in types of TTCN–3. In our test executor these functions are implemented in the Base Library in C++ language. They are available not only in TTCN–3 , but they can be called directly from Test Ports as well.

The prototypes for these functions can be found in $TTCN3_DIR/include/Addfunc.hh, but for easier navigation we list them also in the present document.

The majority of these functions have more than one polymorphic version: when appropriate, one of them takes literal (built-in) C++ types as arguments instead of the objects of equivalent C++ classes. For instance, if the incoming argument is stored in an int variable in your C++ code, you should not construct a temporary object of class INTEGER because passing an int is faster and produces smaller binary code. Similarly, the returned type is also literal when it is possible.

=== Integer to character

extern CHARSTRING int2char(int value);

extern CHARSTRING int2char(const INTEGER& value);

=== Character to integer

extern int char2int(char value);

extern int char2int(const char *value);

extern int char2int(const CHARSTRING& value);

=== Integer to universal character

extern UNIVERSAL_CHARSTRING int2unichar(int value);

extern UNIVERSAL_CHARSTRING int2unichar(const INTEGER& value);

=== Universal character to integer

extern int unichar2int(const universal_char& value);

extern int unichar2int(const UNIVERSAL_CHARSTRING& value);

=== Bitstring to integer

extern INTEGER bit2int(const BITSTRING& value);

=== Hexstring to integer

extern INTEGER hex2int(const HEXSTRING& value);

=== Octetstring to integer

extern INTEGER oct2int(const OCTETSTRING& value);

=== Charstring to integer

extern INTEGER str2int(const char *value);

extern INTEGER str2int(const CHARSTRING& value);

=== Integer to bitstring

extern BITSTRING int2bit(const INTEGER& value, const INTEGER& length);

=== Integer to hexstring

extern HEXSTRING int2hex(const INTEGER& value, const INTEGER& length);

=== Integer to octetstring

extern OCTETSTRING int2oct(const INTEGER& value, const INTEGER& length);

=== Integer to charstring

extern CHARSTRING int2str(int value);

extern CHARSTRING int2str(const INTEGER& value);

=== Length of string Type

This function is built into the equivalent C++ classes of all TTCN–3 string types:

int <any_string_type>::lengthof() const;

=== Number of elements in a structured type

This function is built into the C++ template classes of record of and set of types:

int <any_record_of_or_set_of_type>::size_of() const;

This function is currently not implemented for record and set types.

=== The IsPresent Function

This function is built into the wrapper C++ template class OPTIONAL:

boolean <any_optional_field>::ispresent() const;

=== The IsChosen Function

These functions are built into the equivalent C++ classes of TTCN–3 union types:

boolean <union_type>::ischosen(

<union_type>::union_selection_type checked_selection) const;

=== The regexp Function

extern CHARSTRING regexp(const CHARSTRING& instr,

const CHARSTRING& expression, const INTEGER& groupno);

=== Bitstring to charstring

extern CHARSTRING bit2str(const BITSTRING& value);

=== Hexstring to charstring

extern CHARSTRING hex2str(const HEXSTRING& value);

=== Octetstring to character string

extern CHARSTRING oct2str(const OCTETSTRING& value);

=== Character string to octetstring

extern OCTETSTRING str2oct(const char *value);

extern OCTETSTRING str2oct(const CHARSTRING& value);

=== Bitstring to hexstring

extern HEXSTRING bit2hex(const BITSTRING& value);

=== Hexstring to octetstring

extern OCTETSTRING hex2oct(const HEXSTRING& value);

=== Bitstring to octetstring

extern OCTETSTRING bit2oct(const BITSTRING& value);

=== Hexstring to bitstring

extern BITSTRING hex2bit(const HEXSTRING& value);

=== Octetstring to hexstring

extern HEXSTRING oct2hex(const OCTETSTRING& value);

=== Octetstring to bitstring

extern BITSTRING oct2bit(const OCTETSTRING& value);

=== Integer to float

extern double int2float(int value);

extern double int2float(const INTEGER& value);

=== Float to integer

extern INTEGER float2int(double value);

extern INTEGER float2int(const FLOAT& value);

=== The Random Number Generator Function

The implementation is based on functions srand48 and drand48 of libc.

extern double rnd();

extern double rnd(double seed);

extern double rnd(const FLOAT& seed);

=== The Substring Function

Implemented for all string types.

extern BITSTRING substr(const BITSTRING& value, const INTEGER& index,

const INTEGER& returncount);

extern HEXSTRING substr(const HEXSTRING& value, const INTEGER& index,

const INTEGER& returncount);

extern OCTETSTRING substr(const OCTETSTRING& value, const INTEGER& index,

const INTEGER& returncount);

extern CHARSTRING substr(const CHARSTRING& value, const INTEGER& index,

const INTEGER& returncount);

extern UNIVERSAL_CHARSTRING substr(const UNIVERSAL_CHARSTRING& value,

const INTEGER& index, const INTEGER& returncount);

=== Character string to float

extern double str2float(const char *value);

extern double str2float(const CHARSTRING& value);

=== The Replace Function

Implemented for all string types.

extern BITSTRING replace(const BITSTRING& value, const INTEGER& index,

const INTEGER& len, const BITSTRING& repl);

extern HEXSTRING replace(const HEXSTRING& value, const INTEGER& index,

const INTEGER& len, const HEXSTRING& repl);

extern OCTETSTRING replace(const OCTETSTRING& value, const INTEGER& index,

const INTEGER& len, const OCTETSTRING& repl);

extern CHARSTRING replace(const CHARSTRING& value, const INTEGER& index,

const INTEGER& len, const CHARSTRING& repl);

extern UNIVERSAL_CHARSTRING replace(const UNIVERSAL_CHARSTRING& value,

const INTEGER& index, const INTEGER& len, const UNIVERSAL_CHARSTRING& repl);

[[octetstring-to-character-string-0]]
=== Octetstring to character string

extern CHARSTRING oct2char(const OCTETSTRING& value);

[[character-string-to-octetstring-0]]
=== Character string to octetstring

extern OCTETSTRING char2oct(const char *value);

extern OCTETSTRING char2oct(const CHARSTRING& value);

=== The Decompose Function

Not implemented yet.

=== Additional Non-Standard Functions

extern BITSTRING str2bit(const char *value);

extern BITSTRING str2bit(const CHARSTRING& value);

extern HEXSTRING str2hex(const char *value);

extern HEXSTRING str2hex(const CHARSTRING& value);

extern CHARSTRING float2str(double value);

extern CHARSTRING float2str(const FLOAT& value);template<typename TTCN_TYPE>CHARSTRING ttcn_to_string(const TTCN_TYPE& ttcn_data)template<typename TTCN_TYPE>void string_to_ttcn(const CHARSTRING& ttcn_string, TTCN_TYPE& ttcn_value)extern UNIVERSAL_CHARSTRING oct2unichar(const OCTETSTRING& invalue); extern UNIVERSAL_CHARSTRING oct2unichar(const OCTETSTRING& invalue, const CHARSTRING& string_encoding);extern OCTETSTRING unichar2oct(const UNIVERSAL_CHARSTRING& invalue); extern OCTETSTRING unichar2oct(const UNIVERSAL_CHARSTRING& invalue, const CHARSTRING& string_encoding);extern CHARSTRING get_stringencoding(const OCTETSTRING& encoded__value);extern OCTETSTRING remove_bom(const OCTETSTRING& encoded__value);extern CHARSTRING encode_base64(const OCTETSTRING& msg, bool use_linebreaks);extern CHARSTRING encode_base64(const OCTETSTRING& msg);extern OCTETSTRING decode_base64(const CHARSTRING& b64);

See the section ``Additional predefined functions'' in the Programmer's Technical Reference ([13]) for more details.

== Using the Signature Classes

A Test Port has three outgoing and three incoming types of operation that require the usage of signatures. These are call (getcall), reply (getreply) and raise (catch). Because of this, there are three representation formats (classes generated by the compiler) of a signature the Test Port writer should be familiar with. This section describes these classes using an example.

Let us suppose the following signature definition:

signature MyProc(in integer inPar, out float outPar,

inout bitstring inoutPar)

return hexstring

exception(charstring, integer, boolean);

The classes generated and needed to write a Test Port using this signature are MyProc_call, MyProc_reply and MyProc_exception. These represent the parameters, the return value and the exception type and value of the signature needed by a call, reply or raise.

For example, if a port uses the signature MyProc as an output remote procedure, the Test Port gets the outgoing parameters for a call operation towards the system in an instance of the class MyProc_call. In this case the classes MyProc_reply and MyProc_exception are used for placing an incoming reply or raise operation in the queue of the port (using the functions incoming_reply and incoming_exception of the port class).

=== The Representation of the Input Parameters

The class MyProc_call (using the above example) represents all incoming parameters of the signature MyProc. It temporary stores the parameters inPar and inoutPar.

The generated class MyProc_call will have the following public member functions:

Table Public member functions of the class MyProc_call

[cols=",",options="header",]
|==============================================================
|Member functions |Notes
|_Parameter access functions_ |Gives access to parameter inPar.
|_Other member functions_ |Puts the parameters into log.
|==============================================================

The parameters can be accessed via their access functions that have the same names as the parameters (name mapping also applies to these functions).

=== The Output Parameters and Return Value

The output parameters and return value (if defined) are represented by the class MyProc_reply that has the following public member functions:

Table Public member functions of the class MyProc_reply

[cols=",",options="header",]
|=====================================================================
|Member functions |Notes
|_Parameter access functions_ |
|_Access function for return value_ |Gives access to the return value.
|_Other member functions_ |Puts the parameters into log.
|=====================================================================

The parameters can be accessed by their access functions, and the return value can be accessed via the function return_value().

=== Representation of Signature Exceptions

The class representing the exceptions of a signature (remote procedure) is similar to the representation of the union data type. Using the above example this class is called MyProc_exception. This class is generated only if the signature has at least one exception type.

Table Public member functions of the class MyProc_exception

[width="100%",cols="50%,50%",options="header",]
|===================================================================================================================================================================================================================================
|Member functions |Notes
|_Constructors_ |Initializes to unbound value.
|_Destructor_ |
|_Assignment_ _operator_ |Assigns the given value.
|_Field access functions_ |Selects and gives access to the CHARSTRING field. If other field was previously selected, its value will be destroyed.
|_Other member functions_ |Returns the current selection. It will return MyProc exception::UNBOUND VALUE if the exception is unbound, MyProc exception::ALT CHARSTRING if a charstring value is present in the exception, and so on.
|===================================================================================================================================================================================================================================

If an exception type is a user-defined type the field name will be constructed from the C++ namespace name of the module that the exception type resides in and the name of the C++ class that realizes the exception type. The two identifiers are glued together using a single underscore character. Please note that the namespace name is always present in the identifiers, even if the exception type is defined in the same module as the signature.

For example, if exception type My_Record is defined in module My_Module the respective field access functions will be named as My__Module_My__Record_field and the associated enum value will be MyProc_exception::ALT_My__Module_My__Record.
