= Protocol Module

== Overview

Protocol module implements the message structures of the related protocol in a formalized way, using the standard specification language TTCN-3. This allows definition of test data in TTCN-3 language <<4-references.adoc#_1, ‎[1]>> and correct encoding/decoding of messages when executing test suites using the Titan TTCN-3 test environment <<4-references.adoc#_2, ‎[2]>>.

The XTDP protocol module is implemented in the following files:

* __XTDP_EncDecFunctions.ttcn__
* __XTDL.xsdXTDP-Message.xsd__

The XSD files cannot be used directly. These files will be used when creating XTDP messages.

* __ttcn_ericsson_se_xtdp_xtdp_1_0.ttcn__
* __ttcn_ericsson_se_xtdp_xul_1_0.ttcn__
* _UsefulTtcn3Types.ttcn_
* _XSD.ttcn_

NOTE: Any restrictions present in the XSD should be taken into account when assigning values to the types generated form the XSDs. For example the widget IDs, parentWidgetId-s in XTDP messages, should follow the pattern:

"[a-zA-Z0-9]([a-zA-Z0-9]|_| |\-|\.|/){1,}"

== Installation

The protocol module can be used in developing TTCN-3 test suites using any text editor. However to make the work more efficient a TTCN-3-enabled text editor is recommended (for example `nedit`, `xemacs`). Since the XTDP protocol is used as a part of a TTCN-3 test suite, this requires TTCN-3 Test Executor be installed before the module can be compiled and executed together with other parts of the test suite. For more details on the installation of TTCN-3 Test Executor see the relevant section of <<4-references.adoc#_2, ‎[2]>>.

== Description of Encoding and Decoding Functions

These functions are generated by the TITAN TTCN-3 Test Executor. Module __XTDP_EncDecFunctions.ttcn__ contains the external function declarations of these functions.

== Configuration

=== Configuration for IPL4asp CNL 113 531

For the IPL4asp CNL 113 531 testport the function `f_XTDP_getMsgLen(…)` can be used for message delineation. For example, if we would like to use the component type definition foo_CT, then a possible implementation of a server port opening can be done as in the function `f_connectToServerGui()` example below.

[source]
----
type component foo_CT {
  port IPL4asp_PT IPL4;
…
}

function f_connectToServerGui(in charstring pl_addr, in integer pl_port)
runs on foo_CT return integer //connId
{
  var integer vl_connId;
  //map
  map(self:IPL4, system:IPL4);
  //connect to GUI
  var Result result:= IPL4asp_PortType.f_IPL4_connect(
    IPL4,
    pl_addr, pl_port,
    "0.0.0.0", 0,
    vl_connId, {tcp := {}})
  if (ispresent(result.errorCode)) {
    log("Connection failed: ",result.errorCode);
    setverdict(fail);
    stop;
  }
  log("Connection open: ",result);
  setverdict(pass);
  vl_connId:= result.connId

  //register message dissector for receiving
  var f_IPL4_getMsgLen fcb_msglen := refers(f_XTDP_getMsgLen);
  f_IPL4_setGetMsgLen(IPL4, vl_connId, fcb_msglen, {})

  return vl_connId;
}
----

=== Configuration for TCPasp CNL 113 347

For the TCPasp CNL 113 347 the message delineation can configured via testport parameters, similarly to the following. Let us assume that the TCP port has been named as "tcp_port".

[source]
----
[TESTPORT_PARAMETERS]
system.tcp_port.packet_hdr_length_offset := "0"
system.tcp_port.packet_hdr_nr_bytes_in_length := "4"
system.tcp_port.packet_hdr_byte_order := "MSB"
----
